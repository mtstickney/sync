&IF defined(SHECL_FFI_I_)=0 &THEN
&GLOBAL-DEFINE SHECL_FFI_I_

/* FIXME: breaks if the running AVM is a different architecture than the compiling one. */
&IF defined(PROCESS-ARCHITECTURE) &THEN
&IF {&PROCESS-ARCHITECTURE} = 64 &THEN
&SCOPED-DEFINE POINTER INT64
&SCOPED-DEFINE ABL_POINTER INT64
&ENDIF
&ELSE
&SCOPED-DEFINE POINTER LONG
&SCOPED-DEFINE ABL_POINTER INTEGER
&ENDIF

/* Some basic functionality directly from ECL. */
&SCOPED-DEFINE ECL_DLL "client/bin/ecl.dll"
&SCOPED-DEFINE ECL_API EXTERNAL {&ECL_DLL} CDECL PERSISTENT

PROCEDURE ecl_process_env {&ECL_API}:
        DEFINE RETURN PARAMETER ret AS {&POINTER}
END.

&SCOPED-DEFINE SHECL_DLL "client/bin/shecl.dll"
&SCOPED-DEFINE SHECL_API EXTERNAL {&SHECL_DLL} CDECL PERSISTENT

&GLOBAL-DEFINE FFI_CLOBJECT {&POINTER}
&GLOBAL-DEFINE CLOBJECT {&ABL_POINTER}

PROCEDURE shecl_boot {&SHECL_API}:
        DEFINE INPUT PARAMETER shecl_fasl_path AS CHARACTER NO-UNDO.
        DEFINE INPUT PARAMETER nargs AS LONG NO-UNDO.
        /* A char** param, but you can't pass NULL with a MEMPTR. */
        DEFINE INPUT PARAMETER argv AS LONG NO-UNDO.
        /* FIXME: sizeof(int) != sizeof(long) */
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE shecl_shutdown {&SHECL_API}:
END.

PROCEDURE eval {&SHECL_API}:
        DEFINE INPUT PARAMETER str AS CHARACTER NO-UNDO.
        DEFINE INPUT PARAMETER pool AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE read {&SHECL_API}:
        DEFINE INPUT PARAMETER str AS CHARACTER NO-UNDO.
        DEFINE INPUT PARAMETER pool AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

/* TODO: Add header for multi-value apply calls. */
{client/include/shecl/call.i 1}

PROCEDURE shecl_nvalues {&SHECL_API}:
        DEFINE INPUT PARAMETER env AS {&POINTER} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE shecl_nth_value {&SHECL_API}:
        DEFINE INPUT PARAMETER env AS {&POINTER} NO-UNDO.
        DEFINE INPUT PARAMETER n AS LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

/* Type conversion for CHARACTER types. */
PROCEDURE lisp_string {&SHECL_API}:
        DEFINE INPUT PARAMETER str AS CHARACTER NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE string_p {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

/* FIXME: THis should probably have the same API as the other to-c-type functions. */
PROCEDURE c_string {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS MEMPTR NO-UNDO.
END.

/* Type conversion for DECIMAL types. */
PROCEDURE lisp_double {&SHECL_API}:
        DEFINE INPUT PARAMETER d AS DOUBLE NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE double_p {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE c_double {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE OUTPUT PARAMETER d AS HANDLE TO DOUBLE NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE lisp_int64 {&SHECL_API}:
        DEFINE INPUT PARAMETER i AS INT64 NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE int64_p {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE c_int64 {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE OUTPUT PARAMETER i AS HANDLE TO INT64 NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE lisp_int {&SHECL_API}:
        DEFINE INPUT PARAMETER i AS LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE int_p {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE c_int {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE OUTPUT PARAMETER i AS HANDLE TO LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE lisp_bool {&SHECL_API}:
        DEFINE INPUT PARAMETER b AS LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS {&FFI_CLOBJECT} NO-UNDO.
END.

PROCEDURE bool_p {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE c_bool {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE INPUT PARAMETER b AS HANDLE TO LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE c_generalized_bool {&SHECL_API}:
        DEFINE INPUT PARAMETER obj AS {&FFI_CLOBJECT} NO-UNDO.
        DEFINE INPUT PARAMETER b AS HANDLE TO LONG NO-UNDO.
        DEFINE RETURN PARAMETER ret AS LONG NO-UNDO.
END.

PROCEDURE CheckForErrors:
        DEFINE VAR obj AS {&CLOBJECT} NO-UNDO.
        DEFINE VAR env AS {&ABL_POINTER} NO-UNDO.
        DEFINE VAR n AS INTEGER NO-UNDO.
        DEFINE VAR lispStr AS {&CLOBJECT} NO-UNDO.
        DEFINE VAR errorCStr AS MEMPTR NO-UNDO.
        DEFINE VAR errorMsg AS CHARACTER NO-UNDO.

        RUN ecl_process_env(OUTPUT env).
        RUN ecl_nvalues(env, OUTPUT n).
        IF n <= 1 THEN
                RETURN.

        /* Go get the second return value. */
        RUN ecl_nth_value(env, 1, OUTPUT lispStr).
        /* Now convert it to a C string. */
        RUN c_string(lispStr, OUTPUT errorCStr).
        IF GET-POINTER-VALUE(errorCStr) = 0 THEN
                RETURN ERROR "Error reporting the error message. Ironic, no?".
        /* Now fetch an ABL string out of the buffer and free the original string. */
        errorMsg = GET-STRING(errorCStr, 1).
        SET-SIZE(errorCStr) = 0.
        RETURN ERROR errorMsg.
END.

&ENDIF
